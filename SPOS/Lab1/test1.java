qq2q
22q2
"stf56.4j0g879     o5443     $%^^&G*"
54.4
44.7.4
4.4.4.
4.4..
+++
+++++
/*fhgd.56456    fgc    */
//gxefyu^^%G^&g7       bin dhj
ff.fd
gg.g.g
f.h.

'ghv hbjj'
'hgh 

public class HelloWorld{
	public static void main(String []args){
	    System.out.println("Hello world");
	    int a=2;
	    int b = mwthod(7,98);



import java.util.Arrays;

public class HeapSort {

    public static void main(final String[] args) {
        final int[] a = { 3,4,5,6,2,23,567,9,1,4,0 };
        System.out.println(Arrays.toString(a));
        heapSort(a, a.length);
        System.out.println(Arrays.toString(a));
    }

    private static void heapSort(final int[] array, final int count) {
        heapify(array, count);

        int end = count - 1;
        while (end > 0) {
            swap(array, end, 0);
            siftDown(array, 0, --end);
        }
    }

    private static void swap(final int[] array, final int a, final int b) {
        final int temp = array[a];
        array[a] = array[b];
        array[b] = temp;
    }

    private static void heapify(final int[] array, final int count) {
        int start = count / 2 - 1;

        while (start >= 0) {
            siftDown(array, start, count - 1);
            start--;
        }
    }

    private static void siftDown(final int[] array, final int start, final int end) {
        int root = start;

        while (root * 2 + 1 <= end) {
            int child = root * 2 + 1;
            int swap = root;
            if (array[swap] < array[child]) {
                swap = child;
            }
            if (child + 1 <= end && array[swap] < array[child + 1]) {
                swap = child + 1;
            }
            if (swap != root) {
                swap(array, root, swap);
                root = swap;
            } else {
                return;
            }
        }
    }
}

gavghs
jasdgc
sdhvgb

4.4.4.+
4.4.4+
4+4
4 + 4

Пірамідальне сортування (англ. Heapsort, «Сортування купою») — алгоритм сортування, працює в найгіршому, в середньому і в найкращому випадку (тобто гарантовано) за Θ(n log n) операцій при сортуванні n елементів. Кількість застосовуваної службової пам'яті не залежить від розміру масиву (тобто, O (1)).
